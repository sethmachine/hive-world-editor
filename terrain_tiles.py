"""Manipulation of w3e terrain tile structures.

Refer here for specification: https://github.com/stijnherfst/HiveWE/wiki/war3map.w3e-Terrain

"""

import collections
import json
import os

def value_to_flag(value):
    if value:
        return 1
    else:
        return 0

def unpack_water_and_edge(water_and_edge):
    """

    The highest bit (bit 15) is used for the boundary flag 1.

    0x4000 --> boundary flag 1 (shadow generated by the world editor on the edge of the map)

    The tilepoint "water level" you see on the WE is given by:

    (water_level - 8192) / 4 - 89.6

    Where 8192 is the "ground zero" level, -89.6 is the water zero level.
    The water zero level is a variable value found in Water.slk * 128.
    So if it is -0,7 --> water_zero_level = -0,7 * 128 = -89.6.

    :param water_and_edge:
    :return: water_height: height of water
             boundary: whether tile is on the map edge
    """
    water_height = water_and_edge & 0x3FFF #first 14 bits
    # boundary = (water_and_edge & 0xC000) >> 15 #16th bit
    boundary = '{:016b}'.format(water_and_edge)[:2]
    return water_height, boundary

def pack_water_and_edge(water_height, boundary):
    """
    """
    # first 14 bits
    s = boundary + '{:14b}'.format(water_height)
    # # 15th bit
    # if boundary != 0:
    #     s = '00' + s
    # else:
    #     s = '01' + s
    # s = '{:01b}'.format(boundary) + s
    #16th bit is always 0?
    # s = '0' + s
    return int(s, 2)

def unpack_texture_and_flags(texture_and_flags):
    """
    4bits		flags
    Flags values (shown as big endian):

    0x0010 --> ramp flag (used to set a ramp between two layers)
    0x0020 --> blight flag (ground will look like Undead's ground)
    0x0040 --> water flag (enable water)
    0x0080 --> boundary flag 2 (used on "camera bounds" area.
    Usually set by the World Editor "boundary" tool.)

    4bits		ground_texture
    Which ground textures is used (dirt, grass, rock, etc...).
    This refers to one of the ground tilesets discussed earlier.

    :param texture_and_flags:
    :return:
    """
    ground_texture = texture_and_flags & 0b00001111 # first 4 bits
    # flags = texture_and_flags & 0xF0 # last 4 bits
    ramp_flag = texture_and_flags & 0b00010000
    blight_flag = texture_and_flags & 0b00100000
    water_flag = texture_and_flags & 0b01000000
    boundary_flag_2 = texture_and_flags & 0b10000000
    return ground_texture, ramp_flag, blight_flag, water_flag, boundary_flag_2

def pack_texture_and_flags(ground_texture, ramp_flag, blight_flag, water_flag, boundary_flag_2):
    # first 4 bits is ground texture
    p1 = '{:04b}'.format(ground_texture)
    # last 4 bits are ramp, blight, water, boundary flags
    # 0 is no, >0 is yes
    p2 = '{:01b}{:01b}{:01b}{:01b}'.format(value_to_flag(boundary_flag_2),
                                      value_to_flag(water_flag),
                                      value_to_flag(blight_flag), value_to_flag(ramp_flag))
    s = p2 + p1
    return int(s, 2)

def unpack_variation(variation):
    """
    5bits		ground_variation
    Which variation of the texture to use (bones, holes, etc...).
    This is to reduce the amount of repetition.

    3bits		cliff_variation
    Cliff variations seem to be allowed to be between the range 0 to 7.
    If the cliff variation model isn't available then
    the game will take the highest available one.


    :param variation:
    :return:
    """
    ground_variation = variation & 0b00011111
    cliff_variation = (variation & 0b11100000) >> 5
    return ground_variation, cliff_variation

def pack_variation(ground_variation, cliff_variation):
    # first five bit is variation
    p1 = '{:05b}'.format(ground_variation)
    # last three bits is cliff variation
    p2 = '{:03b}'.format(cliff_variation)
    s = p2 + p1
    return int(s, 2)

def unpack_misc(misc):
    """

    4bits		cliff_texture
    Which cliff texture to use (dirt, grass, snow, etc...).
    While technically this should refer to one of the cliff tilesets
    discussed earlier the cliff tile list is actually ignored,
    the World Editor will simply add the cliff tiles for each tile
    in the ground tile list, if a cliff version of this ground tile exists.

    Note that the value 15 is reserved for unknown reasons.

    4bits		layer_height
    The layer height is changed when using cliffs.

    :param misc:
    :return:
    """
    # last 4 bits
    # shifted because cliff textures are 0 - 15 valued
    # i.e. only 16 possible values
    cliff_texture = (misc & 0b11110000) >> 4
    # first 4 bits
    layer_height = misc & 0b00001111
    return cliff_texture, layer_height

def pack_misc(cliff_texture, layer_height):
    # first 4 bits is cliff layer height
    # need to undo 4 bit shift operation
    # mask was 1111 0000
    p1 = '{:04b}'.format(layer_height)
    # last 4 is cliff texture
    p2 = '{:04b}'.format(cliff_texture)
    s = p2 + p1
    #dont interpret last bit since it's signed
    return int(s, 2)

class Tile():
    def __init__(self, ground_height=None, water_height=None, map_edge_flag=None,
                 ground_texture=None, ramp_flag=None, blight_flag=None,
                 water_flag = None, boundary_flag=None, ground_variation=None,
                 cliff_variation=None, cliff_texture=None, layer_height=None):
        """Representation of a Warcraft III map terrain tile.

        :param ground_height: Elevation of the tile.  Ground level is 8192.  Max is 2 * 8192, min is 0.
        :param water_height: Elevation of water on the tile.  Ground level is -89.6.
        :param map_edge_flag: 0 or 1.  Whether a shadow is generated on the tile (i.e. edge of map)
        :param ground_texture: Integer from 0 to 15 (4 bits).  Determines ground textures used.
        :param ramp_flag: 0 or 1.  Whether a ramp is set between two layers.
        :param blight_flag: 0 or 1.  Whether blight is on top of the tile (Undead ground).
        :param water_flag: 0 or 1.  Enables water on the tile.
        :param boundary_flag: 0 or 1.  Used on "camera bounds" area.  Usually set by World Editor "boundary" tool.
        :param ground_variation: Integer 0 to 31 (5 bits).  Determines which variation of texture that is used to reduce repetition.
        :param cliff_variation: Integer 0 to 7 (3 bits).  Determines which variation of cliff texture to use (?).
        :param cliff_texture: Integer 0 to 15 (4 bits).  Determines which cliff texture is used.
        :param layer_height: Integer 0 to 15 (4 bits).  Layer heigth changes when using cliffs.
        """
        self.ground_height = ground_height
        self.water_height = water_height
        self.map_edge_flag = map_edge_flag
        self.ground_texture = ground_texture
        self.ramp_flag = ramp_flag
        self.blight_flag = blight_flag
        self.water_flag = water_flag
        self.boundary_flag = boundary_flag
        self.ground_variation = ground_variation
        self.cliff_variation = cliff_variation
        self.cliff_texture = cliff_texture
        self.layer_height = layer_height

    def pack(self):
        data = collections.OrderedDict()
        data['ground_height'] = self.ground_height
        data['water_and_edge'] = pack_water_and_edge(self.water_height, self.map_edge_flag)
        data['texture_and_flags'] = pack_texture_and_flags(self.ground_texture, self.ramp_flag,
                                                           self.blight_flag, self.water_flag, self.boundary_flag)
        data['variation'] = pack_variation(self.ground_variation, self.cliff_variation)
        data['misc'] = pack_misc(self.cliff_texture, self.layer_height)
        return data

    def unpack(self, ground_height, water_and_edge, texture_and_flags, variation, misc):
        self.ground_height = ground_height
        self.water_height, self.map_edge_flag = unpack_water_and_edge(water_and_edge)
        self.ground_texture, self.ramp_flag, self.blight_flag, self.water_flag, self.boundary_flag = unpack_texture_and_flags(texture_and_flags)
        self.ground_variation, self.cliff_variation = unpack_variation(variation)
        self.cliff_texture, self.layer_height = unpack_misc(misc)

    def unpack_dict(self, data):
        gh = data['ground_height']
        we = data['water_and_edge']
        tf = data['texture_and_flags']
        vr = data['variation']
        misc = data['misc']
        self.unpack(gh, we, tf, vr, misc)

def test_packing(tile):
    nwe = pack_water_and_edge(tile['water_height'], tile['map_edge'])
    assert nwe == tile['water_and_edge']
    w, b = unpack_water_and_edge(nwe)
    assert w == tile['water_height']
    assert b == tile['map_edge']
    ntf = pack_texture_and_flags(tile['ground_texture'], tile['ramp'], tile['blight'],
                                 tile['water'], tile['boundary'])
    assert ntf == tile['texture_and_flags']
    gt, rf, blf, wf, bf2 = unpack_texture_and_flags(ntf)
    assert gt == tile['ground_texture']
    assert rf == tile['ramp']
    assert blf == tile['blight']
    assert wf == tile['water']
    assert bf2 == tile['boundary']
    nv = pack_variation(tile['ground_variation'], tile['cliff_variation'])
    assert nv == tile['variation']
    gv, cv = unpack_variation(nv)
    assert gv == tile['ground_variation']
    assert cv == tile['cliff_variation']
    nmisc = pack_misc(tile['cliff_texture'], tile['layer_height'])
    assert nmisc == tile['misc']
    ct, lh = unpack_misc(nmisc)
    assert ct == tile['cliff_texture']
    assert lh == tile['layer_height']

def test_packing_2(tile):
    new_tile = Tile()
    new_tile.unpack(tile['ground_height'], tile['water_and_edge'], tile['texture_and_flags'],
                    tile['variation'], tile['misc'])
    assert new_tile.water_height == tile['water_height']
    assert new_tile.map_edge_flag == tile['map_edge']
    assert new_tile.ground_texture == tile['ground_texture']
    assert new_tile.ramp_flag == tile['ramp']
    assert new_tile.blight_flag == tile['blight']
    assert new_tile.water_flag == tile['water']
    assert new_tile.boundary_flag == tile['boundary']
    assert new_tile.ground_variation == tile['ground_variation']
    assert new_tile.cliff_variation == tile['cliff_variation']
    assert new_tile.cliff_texture == tile['cliff_texture']
    assert new_tile.layer_height == tile['layer_height']
    out = new_tile.pack()
    for key in out:
        assert out[key] == tile[key]

def test_tile_packing_unpacking(infile):
    tiles = json.load(open(infile, 'r'))
    for i, tile in enumerate(tiles):
        try:
            test_packing(tile)
            test_packing_2(tile)
        except AssertionError:
            print('Failed on tile #{}'.format(i))
            raise AssertionError('Failed on tile #{}'.format(i))
    print('Passed all tests.')

if __name__ == '__main__':
    test_tile_packing_unpacking('data/test/glacial-tiles.json')
