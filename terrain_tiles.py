"""Manipulation of w3e terrain tile structures.

Refer here for specification: https://github.com/stijnherfst/HiveWE/wiki/war3map.w3e-Terrain

"""

import collections
import json
import os

def value_to_flag(value):
    if value:
        return 1
    else:
        return 0

def unpack_water_and_edge(water_and_edge):
    """

    The highest bit (bit 15) is used for the boundary flag 1.

    0x4000 --> boundary flag 1 (shadow generated by the world editor on the edge of the map)

    The tilepoint "water level" you see on the WE is given by:

    (water_level - 8192) / 4 - 89.6

    Where 8192 is the "ground zero" level, -89.6 is the water zero level.
    The water zero level is a variable value found in Water.slk * 128.
    So if it is -0,7 --> water_zero_level = -0,7 * 128 = -89.6.

    :param water_and_edge:
    :return: water_height: height of water
             boundary: whether tile is on the map edge
    """
    water_height = water_and_edge & 0x3FFF #first 14 bits
    boundary = water_and_edge & 0xC000 #15th bit
    return water_height, boundary

def pack_water_and_edge(water_height, boundary):
    """
    """
    # first 14 bits
    s = '{:14b}'.format(water_height)
    # 15th bit
    s = '{:01b}'.format(boundary) + s
    #16th bit is always 0?
    s = '0' + s
    s = s.replace(' ', '')
    return int(s, 2)

def unpack_texture_and_flags(texture_and_flags):
    """
    4bits		flags
    Flags values (shown as big endian):

    0x0010 --> ramp flag (used to set a ramp between two layers)
    0x0020 --> blight flag (ground will look like Undead's ground)
    0x0040 --> water flag (enable water)
    0x0080 --> boundary flag 2 (used on "camera bounds" area.
    Usually set by the World Editor "boundary" tool.)

    4bits		ground_texture
    Which ground textures is used (dirt, grass, rock, etc...).
    This refers to one of the ground tilesets discussed earlier.

    :param texture_and_flags:
    :return:
    """
    ground_texture = texture_and_flags & 0x0F # first 4 bits
    flags = texture_and_flags & 0xF0 # last 4 bits
    ramp_flag = flags & 0X0010
    blight_flag = flags & 0x0020
    water_flag = flags & 0x0040
    boundary_flag_2 = flags & 0x4000
    return ground_texture, ramp_flag, blight_flag, water_flag, boundary_flag_2

def pack_texture_and_flags(ground_texture, ramp_flag, blight_flag, water_flag, boundary_flag_2):
    # first 4 bits is ground texture
    p1 = '{:04b}'.format(ground_texture)
    # last 4 bits are ramp, blight, water, boundary flags
    # 0 is no, >0 is yes
    p2 = '{:01b}{:01b}{:01b}{:01b}'.format(value_to_flag(boundary_flag_2),
                                      value_to_flag(water_flag),
                                      value_to_flag(blight_flag), value_to_flag(ramp_flag))
    s = p2 + p1
    return int(s, 2)

def unpack_variation(variation):
    """
    5bits		ground_variation
    Which variation of the texture to use (bones, holes, etc...).
    This is to reduce the amount of repetition.

    3bits		cliff_variation
    Cliff variations seem to be allowed to be between the range 0 to 7.
    If the cliff variation model isn't available then
    the game will take the highest available one.


    :param variation:
    :return:
    """
    ground_variation = variation & 31
    cliff_variation = (variation & 224) >> 5
    return ground_variation, cliff_variation

def pack_variation(ground_variation, cliff_variation):
    # first five bit is variation
    p1 = '{:05b}'.format(ground_variation)
    # last three bits is cliff variation
    p2 = '{:03b}'.format(cliff_variation)
    s = p2 + p1
    return int(s, 2)

def unpack_misc(misc):
    """

    4bits		cliff_texture
    Which cliff texture to use (dirt, grass, snow, etc...).
    While technically this should refer to one of the cliff tilesets
    discussed earlier the cliff tile list is actually ignored,
    the World Editor will simply add the cliff tiles for each tile
    in the ground tile list, if a cliff version of this ground tile exists.

    Note that the value 15 is reserved for unknown reasons.

    4bits		layer_height
    The layer height is changed when using cliffs.

    :param misc:
    :return:
    """
    # last 4 bits
    # shifted because cliff textures are 0 - 15 valued
    # i.e. only 16 possible values
    cliff_texture = (misc & 0xF0) >> 4
    # first 4 bits
    layer_height = misc & 0x0F
    return cliff_texture, layer_height

def pack_misc(cliff_texture, layer_height):
    print('IN MISC')
    # first 4 bits is cliff layer height
    # need to undo 4 bit shift operation
    # mask was 1111 0000
    p1 = '{:04b}'.format(layer_height)
    # last 4 is cliff texture
    p2 = '{:04b}'.format(cliff_texture)
    print(p2)
    print(p1)
    s = p2 + p1
    #dont interpret last bit since it's signed
    ns = s[:-1]
    if s[-1] == 1:
        ns = '-' + ns
    else:
        ns = '+' + ns
    print(s, ns)
    return int(s, 2)

def test_packing(tile):
    nwe = pack_water_and_edge(tile['water_height'], tile['boundary'])
    assert nwe == tile['water_and_edge']
    w, b = unpack_water_and_edge(nwe)
    assert w == tile['water_height']
    assert b == tile['boundary']
    ntf = pack_texture_and_flags(tile['ground_texture'], tile['ramp'], tile['blight'],
                                 tile['water'], tile['boundary'])
    assert ntf == tile['texture_and_flags']
    gt, rf, blf, wf, bf2 = unpack_texture_and_flags(ntf)
    assert gt == tile['ground_texture']
    assert rf == tile['ramp']
    assert blf == tile['blight']
    assert wf == tile['water']
    assert bf2 == tile['boundary']
    nv = pack_variation(tile['ground_variation'], tile['cliff_variation'])
    assert nv == tile['variation']
    gv, cv = unpack_variation(nv)
    assert gv == tile['ground_variation']
    assert cv == tile['cliff_variation']
    nmisc = pack_misc(tile['cliff_texture'], tile['layer_height'])
    print(nmisc)
    assert nmisc == tile['misc']


if __name__ == '__main__':
    i = 'data/test/tiles.json'
    t = json.load(open(i, 'r'))
    print(json.dumps(t[0], indent=1))
    for i,x in enumerate(t):
        try:
            test_packing(x)
        except AssertionError:
            print('Failed')
            print(json.dumps(x, indent=1))
            print(i, x)
            break
